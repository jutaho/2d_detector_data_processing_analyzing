#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Read mcc-file generated by software "BeamAdjust" type "Octavius 1600 XDR".
Create an interpolated tiff-file. 

juh
"""

import os
import glob
import re
import numpy as np
from tifffile import TiffWriter
from PIL import Image

class MCCProcessor:
    def __init__(self, layout_file):
        self.detector_layout = np.load(layout_file)

    def read_1600xdr_mcc(self, file):
        """
        Read mcc-file type Octavius 1600 XDR.
        """
        dose_values = []
        chamber_number = []
        
        string_pattern = re.compile("#")
        octavius_pattern = re.compile("DETECTOR=OCTAVIUS_1600_XDR")
        
        try:
            with open(file) as raw_data:
                for line in raw_data:
                    if string_pattern.search(line):
                        relevant_values = line.split('\t')
                        dose_values.append(float(relevant_values[5]))
                        chamber = relevant_values[7].strip('#\n')
                        chamber_number.append(int(chamber))
                    else: 
                        break
                                              
        except FileNotFoundError:
            raise FileNotFoundError(f"The file {file} was not found.")
        except Exception as e:
            raise Exception(f"An error occurred while reading the file: {e}")
        
        dose_values = np.array(dose_values)
        chamber_number = np.array(chamber_number)
        
        # Strip profiles and diagonales
        dose_values = dose_values[0:-135]
        chamber_number = chamber_number[0:-135]
        mcc_data_container = np.array([chamber_number, dose_values])
        
        dose_matrix = self.detector_layout.copy()
        for rows in range(dose_matrix.shape[0]):
            for cols in range(dose_matrix.shape[1]):
                if not np.isnan(dose_matrix[rows, cols]):
                    indices = np.where(mcc_data_container[0] == dose_matrix[rows, cols])
                    if indices[0].size == 1:
                        indices = indices[0][0]
                        dose = mcc_data_container[1][indices]
                        dose_matrix[rows, cols] = dose

        dose_container = dose_matrix
        dose_container[dose_container < 0] = 0
        
        return dose_container

    def interpolate_nan(self, dose_container):
        """
        Interpolates NaN values in the dose container using bilinear interpolation.
        """
        y, x = np.indices(dose_container.shape)
        valid_mask = ~np.isnan(dose_container)
        invalid_mask = np.isnan(dose_container)

        interpolated_dose_array = np.copy(dose_container)

        for i in range(dose_container.shape[0]):
            for j in range(dose_container.shape[1]):
                if invalid_mask[i, j]:
                    neighbors = []
                    
                    if i > 0 and valid_mask[i - 1, j]:
                        neighbors.append(dose_container[i - 1, j])
                    if i < dose_container.shape[0] - 1 and valid_mask[i + 1, j]:
                        neighbors.append(dose_container[i + 1, j])
                    if j > 0 and valid_mask[i, j - 1]:
                        neighbors.append(dose_container[i, j - 1])
                    if j < dose_container.shape[1] - 1 and valid_mask[i, j + 1]:
                        neighbors.append(dose_container[i, j + 1])
                    
                    if neighbors:
                        interpolated_dose_array[i, j] = np.median(neighbors)

        return interpolated_dose_array

    def bilinear_interpolate(self, source, scale=10):
        """
        Perform bilinear interpolation on a 2D array to scale up the resolution.
        """
        src_h, src_w = source.shape
        dst_h, dst_w = (src_h * scale) + 1, (src_w * scale) + 1

        dst_y, dst_x = np.mgrid[0:dst_h, 0:dst_w]
        src_x = dst_x / scale
        src_y = dst_y / scale

        x0 = np.floor(src_x).astype(np.int32)
        x1 = x0 + 1
        y0 = np.floor(src_y).astype(np.int32)
        y1 = y0 + 1

        x0 = np.clip(x0, 0, src_w - 1)
        x1 = np.clip(x1, 0, src_w - 1)
        y0 = np.clip(y0, 0, src_h - 1)
        y1 = np.clip(y1, 0, src_h - 1)

        Ia = source[y0, x0]
        Ib = source[y1, x0]
        Ic = source[y0, x1]
        Id = source[y1, x1]

        wa = (x1 - src_x) * (y1 - src_y)
        wb = (x1 - src_x) * (src_y - y0)
        wc = (src_x - x0) * (y1 - src_y)
        wd = (src_x - x0) * (src_y - y0)

        dst = wa * Ia + wb * Ib + wc * Ic + wd * Id

        return dst

    def write_tiff_file(self, dose_array, output_path):
        """
        Write the dose array to a TIFF file.
        """
        
        scale = 10
        pixel_spacing_mm = 2.5 / scale
        pixel_spacing_inch = pixel_spacing_mm / 25.4
        resolution_ppi = 1 / pixel_spacing_inch
        
        bit_resolution = (2**16 - 1)
        normalize_dose = np.max(dose_array)
        norm_factor = bit_resolution / normalize_dose
        
        dose_array_16bit = (dose_array * norm_factor).astype(np.uint16)
        dose_array_inv_16bit = bit_resolution - dose_array_16bit
        
        dose_array_inv_16bit = np.rot90(dose_array_inv_16bit, 3)
        dose_array_inv_shift_y_16bit = np.roll(dose_array_inv_16bit, shift=5, axis=0)
        dose_array_inv_shift_16bit = np.roll(dose_array_inv_shift_y_16bit, shift=-5, axis=1)
        
        
        with TiffWriter(output_path) as tif:
            tif.write(dose_array_inv_shift_16bit, resolution=(resolution_ppi, resolution_ppi), metadata=None)
            #print(output_path)
        
        with Image.open(output_path) as img:
            img.tag_v2[305] = f"PTW;Software:Mephysto MCC;Unit:Gy;Norm:{normalize_dose};Offset:0.00;Normalization:{normalize_dose}"
            #img.save(output_path, tiffinfo=img.tag_v2)
            
        return dose_array_inv_shift_16bit

    def process(self, folder_path):
        """
        Process all .mcc files in a folder, converting them to .tiff files with the same name.
        """
        mcc_files = glob.glob(os.path.join(folder_path, "*.mcc"))
        
        if not mcc_files:
            print("No .mcc files found in the specified folder.")
            return

        for mcc_file in mcc_files:
            try:
                doses = self.read_1600xdr_mcc(mcc_file)
                dose_array = self.interpolate_nan(self.interpolate_nan(doses))
                dose_image = self.bilinear_interpolate(dose_array)
                tiff_file = os.path.splitext(mcc_file)[0] + "_py.tiff"
                self.write_tiff_file(dose_image, tiff_file)
                print(f"\nSuccessfully processed {mcc_file} to {tiff_file}.")
            except Exception as e:
                print(f"\nFailed to process {mcc_file}: {e}")
        
        return dose_image


if __name__ == "__main__":
    layout_file = "layout_octavius1600xdr.npy"
    default_folder = "c:\\LokaleDaten\\Scripting\\analyzing\\test\\"
    
    processor = MCCProcessor(layout_file)
    processor.process(default_folder)
