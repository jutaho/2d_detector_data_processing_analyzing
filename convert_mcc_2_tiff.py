#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Read mcc-file generated by software "BeamAdjust" type "Octavius 1600 XDR".
Create an interpolated tiff-file. 

juh, 310591
"""

import os
import glob
import re
import tkinter as tk
from tkinter import filedialog
import numpy as np
from tifffile import TiffWriter
from PIL import Image
       
def read_1600xdr_mcc(file):
    """
    read mcc-file type Octavius 1600 XDR.

    Parameters
    ----------
    file : mcc-file generated by PTW software "BeamAdjust" type Octavius 1600 XDR 

    Returns
    -------
    dose_container : np.array with dose values and NaNs
    
    """
    # Define empty lists 
    dose_values = []
    chamber_number = []
  
    # Load chamber layout Octavois 1600 XDR 
    detector_layout = np.load('layout_OD1600XDR.npy')
    
    # Extract only dose values and chamber indices
    string_pattern = re.compile('#') 
    
    try:
       with open(file) as raw_data:
           for line in raw_data:
               if string_pattern.search(line):
                   relevant_values = line.split('\t')
                   dose_values.append(float(relevant_values[5]))
                   chamber = relevant_values[7].strip('#\n')
                   chamber_number.append(int(chamber))
    except FileNotFoundError:
       raise FileNotFoundError(f"The file {file} was not found.")
    except Exception as e:
       raise Exception(f"An error occurred while reading the file: {e}")
       
    dose_values = np.array(dose_values)
    chamber_number = np.array(chamber_number)
    
    # Cut last three blocks = central profile, first and second diagonals
    dose_values = dose_values[0:-135]
    chamber_number = chamber_number[0:-135]
    mcc_data_container = np.array([chamber_number, dose_values])
        
    # Create copy of layout, store dose values, keep nan
    dose_matrix = detector_layout.copy()
    for rows in range(dose_matrix.shape[0]):
        for cols in range(dose_matrix.shape[1]):
            if not np.isnan(dose_matrix[rows, cols]):
                # Find indices in mccDataContainer where the chamber number matches dose_matrix[rows, cols]
                indices = np.where(mcc_data_container[0] == dose_matrix[rows, cols])
                if indices[0].size == 1:  # Check if there is only one corresponding match
                    # Extract the matching indices
                    indices = indices[0][0]
                    # Get the corresponding dose value for this indices
                    dose = mcc_data_container[1][indices]
                    # Assign the dose value to dose_matrix
                    dose_matrix[rows, cols] = dose
                    
    dose_container = dose_matrix
    
    # Set negative charges = 0 
    dose_container[dose_container < 0] = 0
    
    return dose_container

def interpolate_nan(dose_container):
    """
    Interpolates NaN values in the dose container using bilinear interpolation.
    In order to get rid of the NaNs that had no valid neighbors
    the function needs to be repeated.

    Parameters
    ----------
    dose_container : np.array
        2D array with NaN values to interpolate.

    Returns
    -------
    interpolated_dose_array = np.array
        Array with NaN values interpolated.
        
    """
    y, x = np.indices(dose_container.shape)
    
    # Create masks for valid and invalid points
    valid_mask = ~np.isnan(dose_container)
    invalid_mask = np.isnan(dose_container)

    # Create arrays to store interpolated values
    interpolated_dose_array = np.copy(dose_container)

    # Perform initial interpolation for all points, including NaNs
    for i in range(dose_container.shape[0]):
        for j in range(dose_container.shape[1]):
            if invalid_mask[i, j]:
                # Find the nearest non-NaN neighbors
                neighbors = []
                
                # Check the top neighbor 
                if i > 0 and valid_mask[i - 1, j]:
                    neighbors.append(dose_container[i - 1, j])
                    
                # Check the bottom neighbor    
                if i < dose_container.shape[0] - 1 and valid_mask[i + 1, j]:
                    neighbors.append(dose_container[i + 1, j])
                    
                # Check the left neighbor    
                if j > 0 and valid_mask[i, j - 1]:
                    neighbors.append(dose_container[i, j - 1])
                    
                # Check the right neighbor    
                if j < dose_container.shape[1] - 1 and valid_mask[i, j + 1]:
                    neighbors.append(dose_container[i, j + 1])
                    
                        
                if neighbors:
                    # Use median to avoid ripples in high gradient areas 
                    # from 2.5 to 5.0 mm pixel shift... 
                    interpolated_dose_array[i, j] = np.median(neighbors)

    return interpolated_dose_array

def bilinear_interpolate(source, scale=10):
    """
    Perform bilinear interpolation on a 2D array to scale up the resolution.

    Parameters
    ----------
    src : np.array
        2D array to be interpolated.
    scale : int - optional, per default "10" according to PTW software veriSoft
        Factor by which to increase the grid resolution.

    Returns
    -------
    dst : np.array
        Interpolated 2D array with increased resolution.
        
    """
    src_h, src_w = source.shape
    dst_h, dst_w = (src_h * scale) +1, (src_w * scale) +1

    # Create coordinate grid for the destination
    dst_y, dst_x = np.mgrid[0:dst_h, 0:dst_w]

    # Calculate the corresponding coordinates in the source array
    src_x = dst_x / scale
    src_y = dst_y / scale

    # Calculate the coordinates of the four neighbors
    x0 = np.floor(src_x).astype(np.int32)
    x1 = x0 + 1
    y0 = np.floor(src_y).astype(np.int32)
    y1 = y0 + 1

    # Clip coordinates to be within the valid range
    x0 = np.clip(x0, 0, src_w - 1)
    x1 = np.clip(x1, 0, src_w - 1)
    y0 = np.clip(y0, 0, src_h - 1)
    y1 = np.clip(y1, 0, src_h - 1)

    # Retrieve values at the four neighbors
    Ia = source[y0, x0]
    Ib = source[y1, x0]
    Ic = source[y0, x1]
    Id = source[y1, x1]

    # Calculate the weights
    wa = (x1 - src_x) * (y1 - src_y)
    wb = (x1 - src_x) * (src_y - y0)
    wc = (src_x - x0) * (y1 - src_y)
    wd = (src_x - x0) * (src_y - y0)

    # Compute the interpolated values
    dst = wa * Ia + wb * Ib + wc * Ic + wd * Id

    return dst

def write_tiff_file(dose_array, output_path):
    """
    Parameters
    ----------
    dose_array : np.array  

    Returns
    -------
    16 bit tif-file

    """
    # Set the resolution in terms of pixel shift
    # The initial shift of the ionization chambers = 2.5 mm
    scale = 10
    pixel_spacing_mm = 2.5 / scale
    pixel_spacing_inch = pixel_spacing_mm / 25.4
    resolution_ppi = 1 / pixel_spacing_inch
    
    # Set bit resolution to 16 bits and get normalize_doe
    bit_resolution = (2**16 - 1)
    normalize_dose = np.max(dose_array)
    norm_factor = bit_resolution / normalize_dose
    
    # Convert array to 16 bit array
    dose_array_16bit = (dose_array * norm_factor).astype(np.uint16)
    dose_array_inv_16bit = bit_resolution - dose_array_16bit
    
    # Rotate to match PTW software "veriSoft" outputs 
    dose_array_inv_16bit = np.rot90(dose_array_inv_16bit, 3)
    
    # Translate to match PTW software "veriSoft" outputs
    dose_array_inv_shift_y_16bit = np.roll(dose_array_inv_16bit, shift=5, axis=0)
    dose_array_inv_shift_16bit = np.roll(dose_array_inv_shift_y_16bit, shift=-5, axis=1)
    
   # Write TIFF file
    with TiffWriter(output_path) as tif:
        tif.write(
            dose_array_inv_shift_16bit, 
            resolution=(resolution_ppi, resolution_ppi)
        )
        
    # Open the TIFF file and add the "Software" tag
    # This had to be implemented in order to be read by VeriSoft and BeamAdjust 
    with Image.open(output_path) as img:
        img.tag_v2[305] = f"PTW;Software:Mephysto MCC;Unit:Gy;Norm:{normalize_dose};Offset:0.00;Normalization:{normalize_dose}"  # 305 is the tag ID for Software
        img.save(output_path, tiffinfo=img.tag_v2)

    return dose_array_inv_shift_16bit

def process_folder(folder_path):
    """
    Process all .mcc files in a folder, converting them to .tiff files with the same name.

    Parameters
    ----------
    folder_path : str
        Path to the folder containing .mcc files.
    scale : int
        Factor by which the original resolution has been scaled.
    """
    mcc_files = glob.glob(os.path.join(folder_path, "*.mcc"))
    if not mcc_files:
        print("No .mcc files found in the specified folder.")
        return

    for mcc_file in mcc_files:
        try:
            doses = read_1600xdr_mcc(mcc_file)
            dose_array = interpolate_nan(interpolate_nan(doses))
            dose_image = bilinear_interpolate(dose_array)
            tiff_file = os.path.splitext(mcc_file)[0] + "_py.tiff"
            write_tiff_file(dose_image, tiff_file)
            print(f"\nSuccessfully processed {mcc_file} to {tiff_file}.")
            
        except Exception as e:
            print(f"\nFailed to process {mcc_file}: {e}")
            
    return doses, dose_array, dose_image

def select_folder_and_process(default_folder):
    """
    Open a dialog for the user to select a folder, then process all .mcc files in that folder.

    """
    root = tk.Tk()
    root.withdraw()  # Hide the root window
    folder_path = filedialog.askdirectory(initialdir=default_folder)  # Ask the user to select a directory
    if not folder_path:
        folder_path = default_folder
    doses, dose_array, dose_image = process_folder(folder_path)
    
    return doses, dose_array, dose_image

# Usage when directly called
if __name__ == "__main__":
    default_folder = "r://Therapie_QA//2024//H1//E-2-2-1-HomogenitÃ¤t//06.Juni//TEST//"
    doses, dose_array, dose_image = select_folder_and_process(default_folder)
    

